---
title: "[SQL/캡스톤디자인] 데이터베이스 과제 6주차"
date: 2025-05-13 00:43:00 +0900
categories: [캡스톤디자인, 데이터베이스]
tags:
  [
    SQL,
    컴퓨터공학부,
    데이터베이스
  ]
---
# 데이터베이스6주차

이번 주차에는 지난 설계 기반으로 실제 코드를 구현해보는 데 집중하였다. 특히 백엔드 구조 통합 실험을 위해 Flask를 중심으로 MySQL과 MongoDB를 동시에 연결하고, 사용자 활동 로그를 실제로 저장하고 불러오는 전체 API 흐름을 작성하였다.
Flask 프로젝트 구조는 app.py를 중심으로, MySQL ORM은 SQLAlchemy로, MongoDB 연결은 mongo.py를 통해 PyMongo로 구성하였다. 실제 구현에서는 사용자 정보, 노트, 결제 정보를 MySQL에 저장하고, 사용자 활동 로그는 /log/activity라는 엔드포인트를 통해 MongoDB에 저장되도록 분리하였다. 이 구조는 앞서 설계한 느슨한 결합(Loose Coupling)을 실제 코드로 구현한 예라고 할 수 있다.MongoDB 쪽 구현에서는 mongo_routes.py 파일에 Blueprint를 사용하여 라우트를 등록하였고, POST 요청이 들어오면 사용자 ID, 액션, 노트 ID, 타임스탬프, IP 주소 등을 받아 하나의 로그 문서로 삽입하도록 구성했다. 확인 결과 실제로 MongoDB에는 user_activity_logs 컬렉션에 로그 문서가 정상적으로 삽입되었으며, GET 요청으로도 특정 사용자 ID의 로그 기록을 불러올 수 있었다.
이번 구현을 통해 실제 서비스 흐름의 기반을 어느 정도 확보했으며, Flask에서의 이중 DB 구조가 실질적으로 작동 가능함을 확인할 수 있었다. 다만 한 가지 과제로는 MongoDB 로그 저장이 실패할 경우를 가정한 에러 처리 및 백업 저장 방식을 구현하는 것이다. 이를 위해 차주에는 Redis 기반의 RQ 큐를 활용하여 로그를 큐로 발행한 후, 실패 시 로컬 백업이나 재시도 구조를 실험해볼 예정이다.
또한 MongoDB에 저장된 활동 로그를 바탕으로 사용자별 피드백을 자동 생성하는 AI 구조도 함께 구상해보고, 초기 버전을 POST /log/feedback 등으로 확장하는 방안도 제안해볼 계획이다.

로그 저장 중 MongoDB 연결 실패 또는 데이터 형식 오류 등 예외 처리를 위해 try-except 블록을 구성하였다. Flask Blueprint 내에서 삽입 오류가 발생하면 JSON으로 에러 메시지를 반환하도록 하여 디버깅이 용이하도록 설계하였다. 사용자 활동 로그 외에, 향후 AI 기반 피드백 데이터를 별도 컬렉션(ai_feedback_logs)에 저장할 수 있도록 구조를 설계하였다. 이는 학습자별 피드백 흐름을 분리 관리함으로써 분석 효율성과 시스템 분리를 동시에 확보하는 데에 목적이 있다.단일 요청에서 두 DB가 동시에 관여되는 경우를 대비해, MySQL 성공 후 MongoDB 실패 시 해당 로그를 큐에 따로 적재하거나, 실패 내역을 error_logs에 보관하여 후처리하는 전략도 고려하였다.RQ를 이용한 큐 구조를 실험하기 위해, Flask 앱에서 큐 등록 및 백그라운드 워커 실행 구조를 정리하였다. 학습 로그 삽입을 태스크로 만들어 큐에 적재한 뒤, 워커에서 MongoDB에 저장하도록 하는 실험을 차주에 시도할 예정이다.MongoDB 라우트 테스트 결과, 정상적인 요청 시 로그가 JSON 형태로 반환되었고, 누락 필드로 인한 잘못된 POST 요청은 400 에러로 응답되었다. 이는 기본적인 라우트의 안정성 확보 단계로 판단된다.
차주엔,document형태의 MongoDB를 다시 분석을 해볼 예정이다.